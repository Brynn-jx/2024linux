退出机制的设计
设计一个父进程专门用来接受信号和处理子进程退出，这个子进程就是主线程，这样可以向父进程发送信号而不影响子进程中的线程
并且可以提升可靠性，当子进程挂掉的时候第一时间启动起来。
pthread_cancel(factory.thidAddr[j])在多线程的情况下单纯的使用cancel不行，因为pthread_cond_wait可能在后半部分要获取锁，然后向下执行，但是一个线程
被cancel后这个线程没有开锁，导致后续的线程无法在后半部分获得锁了，所以就阻塞了。
所以需要pthread_cleanup_push 和 pthread_cleanup_pop，他们是定义线程取消（通过 pthread_cancel）时需要执行的清理处理程序的函数。这些函数允许你在关键代码段中注册一个或多个清理处理程序，
以便在线程被取消或者正常退出该代码段时自动调用它们来执行必要的清理工作。

3.0
子进程异常退出后，父进程重新启动子进程
父进程先退出会导致输出显示异常

netdisk1.0
现在服务器能够默认监控的并发请求是100
一开始监听的请求是客户端连接和有序退出
控制码100之前是服务器的，100之后是客户端的
events 是一个 32 位的无符号整数，表示感兴趣的事件类型。
常用的事件类型包括：
EPOLLIN：文件描述符可读。
EPOLLOUT：文件描述符可写。
EPOLLERR：文件描述符发生错误。
EPOLLHUP：文件描述符被挂起（如对端关闭连接）。
EPOLLET：将文件描述符设置为边缘触发模式（Edge Triggered）。
EPOLLONESHOT：事件只触发一次，触发后需要重新注册。
水平触发：对于可读事件，只要有数据未被读取，就会一直触发。

改进：
strtok不是线程安全的，原因在于它的内部实现使用了一个静态（static）的指针来保存解析字符串的状态。这个静态变量在所有对该函数的调用之间共享